#ifndef SCENEMANAGER_H_
#define SCENEMANAGER_H_
//------------------------------------------------------------------------------
/**
    @class chrissly::graphics::SceneManager

    (C) 2011 Christian Bleicher
*/
#include "camera.h"
#include "entity.h"
#include "scenenode.h"
#include "light.h"
#include "renderqueue.h"
#include "rendertexture.h"
#include "rendersystem.h"
#include "linkedlist.h"
#include "hashtable.h"
#include "matrix4.h"

//------------------------------------------------------------------------------
namespace chrissly
{
namespace graphics
{

class SceneManager
{
public:
    /// describes the stage of rendering when performing complex illumination
    enum IlluminationRenderStage
    {
        /// no special illumination stage
        IRS_NONE,
        /// render to texture stage, used for texture based shadows
        IRS_RENDER_TO_TEXTURE,
        /// render from shadow texture to receivers stage
        IRS_RENDER_RECEIVER_PASS
    };

    /// get pointer to the singleton
    static SceneManager* const Instance()
    {
        return Singleton;
    }

    /// default constructor
    SceneManager();
    /// destructor
    ~SceneManager();
    /// creates a camera to be managed by this scene manager
    Camera* const CreateCamera(const char* const name);
     /// retrieves a pointer to the camera
    Camera* const GetCamera(const char* const name) const;
     /// removes (and destroys) all cameras from the scene
    void DestroyAllCameras();

    /// creates a named light for use in the scene
    Light* const CreateLight(const char* const name);
    /// returns a pointer to the named Light which has previously been added to the scene
    Light* const GetLight(const char* const name) const;
    /// returns a pointer to the hashtable that contains all lights
    ce_hash_table* const GetAllLights() const;
    /// removes the light from the scene and destroys it
    void DestroyLight(Light* const light);
    /// removes and destroys all lights in the scene
    void DestroyAllLights();

    /// create an Entity (instance of a discrete mesh) with an autogenerated name
    /**
        @param
        meshName The name of the Mesh it is to be based on (e.g. 'knot.mesh'). The
        mesh will be loaded if it is not already.
    */
    Entity* const CreateEntity(const char* const meshName);
    /// destroys the given Entity instance
    void DestroyEntity(Entity* const entity);

    /// creates an instance of a SceneNode
    /**
        @remarks
            Note that this does not add the SceneNode to the scene hierarchy.
            This method is for convenience, since it allows an instance to
            be created for which the SceneManager is responsible for
            allocating and releasing memory, which is convenient in complex
            scenes.
        @par
            To include the returned SceneNode in the scene, use the addChild
            method of the SceneNode which is to be it's parent.
        @par
            Note that this method takes no parameters, and the node created is unnamed (it is
            actually given a generated name, which you can retrieve if you want).
            If you wish to create a node with a specific name, call the alternative method
            which takes a name parameter.
    */
    SceneNode* const CreateSceneNode();
    /// destroys the given SceneNode instance
    void DestroySceneNode(SceneNode* const node);
    /// gets the SceneNode at the root of the scene hierarchy
    /**
        @remarks
            The entire scene is held as a hierarchy of nodes, which
            allows things like relative transforms, general changes in
            rendering state etc (See the SceneNode class for more info).
        @par
            However, in all cases there is only ever one root node of
            the hierarchy, and this method returns a pointer to it.
    */
    SceneNode* const GetRootSceneNode();

    /// empties the entire scene, inluding all SceneNodes, Entities, Lights etc.
    /** 
        Cameras are not deleted at this stage since they are still referenced
        by viewports, which are not destroyed during this process.
    */
    void ClearScene();

    /// sets the ambient light level to be used for the scene
    /**
        @remarks
            This sets the colour and intensity of the ambient light in the scene, i.e. the
            light which is 'sourceless' and illuminates all objects equally.
            The colour of an object is affected by a combination of the light in the scene,
            and the amount of light that object reflects.
        @remarks
            By default the ambient light in the scene is 0x00000000, i.e. no ambient light. This
            means that any objects rendered with a Material which has lighting enabled
            will not be visible unless you have some dynamic lights in your scene.
    */
    void SetAmbientLight(unsigned int colour);
    /// returns the ambient light level to be used for the scene.
    const unsigned int GetAmbientLight() const;
    /// sets the general shadow technique to be used in this scene
    void SetShadowTechnique(ShadowTechnique technique);
    /// gets the current shadow technique
    ShadowTechnique GetShadowTechnique() const;
    /// is there any shadowing technique in use?
    bool IsShadowTechniqueInUse() const;
    /// sets the colour used when rendering to the shadow texture
    void SetShadowColour(unsigned int colour);
    /// gets the colour used when rendering to the shadow texture
    unsigned int GetShadowColour() const;
    /// returns a pointer to the shadow texture currently in use at the given index
    Texture* const GetShadowTexture(size_t index) const;
    /// prompts the class to send its contents to the renderer
    void _RenderScene(Camera* const camera, Viewport* const vp);
    /// internal method for setting up the renderstate for a rendering pass
    void _SetPass(Pass* const pass);
    /// indicates to the SceneManager whether it should suppress changing the RenderSystem states when rendering objects
    /**
        @note
            Calling this implicitly disables shadow processing since no shadows
            can be rendered without changing state.
    */
    void _SuppressRenderStateChanges(bool suppress);
    /// sets a callback which will be notified when render queues are finished processing
    typedef void(*RenderQueuesEndedCallback)();
    void _SetRenderQueuesEndedCallback(RenderQueuesEndedCallback callback);
    /// sets a callback which will be notified when an entity was created
    typedef void(*EntityCallback)(Entity*);
    void _SetEntityCreatedCallback(EntityCallback callback);
    /// sets a callback which will be notified when an entity was destroyed
    void _SetEntityDestroyedCallback(EntityCallback callback);

private:
    /// copy constructor
    SceneManager(const SceneManager&);
    /// prevent copy by assignment
    SceneManager& operator = (const SceneManager&);
    /// destroys all Texture-based shadow related objects
    void DestroyShadowTextures();
    /// method for preparing shadow textures ready for use in a regular render
    void PrepareShadowTextures();
    /// render the objects in a given queue group 
    void RenderQueueGroupObjects(RenderQueue* const queue);
    /// render a group rendering only transparent shadow casters
    void RenderTransparentTextureShadowCasterQueueGroupObjects(RenderQueue* const queue);
    /// render a group rendering only shadow receivers
    void RenderTextureShadowReceiverQueueGroupObjects(RenderQueue* const queue);

    static SceneManager* Singleton;

    unsigned int frameNumber;
    mutable ce_hash_table cameras;
    mutable ce_hash_table lights;
    Entity** entities;
    SceneNode** sceneNodes;
    SceneNode* sceneRoot;
    unsigned int ambientLight;
    RenderSystem* destRenderSystem;
    RenderQueue renderQueueOpaque;
    RenderQueue renderQueueTransparent;
    RenderQueue renderQueueTransparentShadowCaster;
    RenderQueue renderQueueShadowReceiver;
    RenderQueuesEndedCallback renderQueuesEndedCallback;
    bool suppressRenderStateChanges;
    EntityCallback entityCreatedCallback;
    EntityCallback entityDestroyedCallback;

    IlluminationRenderStage illuminationStage;
    ShadowTechnique shadowTechnique;
    unsigned int shadowColour;
    bool shadowTextureConfigDirty;

    Texture* shadowTexture;
    RenderTexture* shadowRenderTexture;
    Camera* shadowCamera;
    Pass* shadowRttPass;
    Pass* shadowRttMorphAnimPass;
    Pass* shadowRttSkeletalAnimPass;
    Pass* shadowPass;
    core::Matrix4 shadowTextureProjScaleTrans;
    core::Matrix4 shadowProjection;
};

} // namespace graphics
} // namespace chrissly
//------------------------------------------------------------------------------
#endif
