#ifndef SCENEMANAGER_H_
#define SCENEMANAGER_H_
//------------------------------------------------------------------------------
/**
    @class chrissly::graphics::SceneManager

    (C) 2011 Christian Bleicher
*/
#include "camera.h"
#include "entity.h"
#include "scenenode.h"
#include "renderqueuesortinggrouping.h"
#include "rendertexture.h"
#include "rendersystem.h"
#include "linkedlist.h"
#include "hashtable.h"
#include "matrix4.h"

//------------------------------------------------------------------------------
namespace chrissly
{
namespace graphics
{

class SceneManager
{
public:
    /// Describes the stage of rendering when performing complex illumination
    enum IlluminationRenderStage
    {
        /// no special illumination stage
        IRS_NONE,
        /// render to texture stage, used for texture based shadows
        IRS_RENDER_TO_TEXTURE,
        /// render from shadow texture to receivers stage
        IRS_RENDER_RECEIVER_PASS
    };

    /// get pointer to the singleton
    static SceneManager* Instance()
    {
        return Singleton;
    }

    /// default constructor
    SceneManager();
    /// destructor
    ~SceneManager();
    /// creates a camera to be managed by this scene manager
    Camera* CreateCamera(const char* name);
     /// retrieves a pointer to the camera
    Camera* GetCamera(const char* name);
     /// removes (and destroys) all cameras from the scene
    void DestroyAllCameras();
    /// create an Entity (instance of a discrete mesh) with an autogenerated name
    /**
        @param
        meshName The name of the Mesh it is to be based on (e.g. 'knot.mesh'). The
        mesh will be loaded if it is not already.
    */
    Entity* CreateEntity(const char* meshName);
 
    /// creates an instance of a SceneNode
    /**
        @remarks
            Note that this does not add the SceneNode to the scene hierarchy.
            This method is for convenience, since it allows an instance to
            be created for which the SceneManager is responsible for
            allocating and releasing memory, which is convenient in complex
            scenes.
        @par
            To include the returned SceneNode in the scene, use the addChild
            method of the SceneNode which is to be it's parent.
        @par
            Note that this method takes no parameters, and the node created is unnamed (it is
            actually given a generated name, which you can retrieve if you want).
            If you wish to create a node with a specific name, call the alternative method
            which takes a name parameter.
    */
    SceneNode* CreateSceneNode();
    /// gets the SceneNode at the root of the scene hierarchy
    /**
        @remarks
            The entire scene is held as a hierarchy of nodes, which
            allows things like relative transforms, general changes in
            rendering state etc (See the SceneNode class for more info).
            In this basic SceneManager class, the application using
            Ogre is free to structure this hierarchy however it likes,
            since it has no real significance apart from making transforms
            relative to each node (more specialised subclasses will
            provide utility methods for building specific node structures
            e.g. loading a BSP tree).
        @par
            However, in all cases there is only ever one root node of
            the hierarchy, and this method returns a pointer to it.
    */
    SceneNode* GetRootSceneNode();
    
    /// empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets etc.
    /** 
        Cameras are not deleted at this stage since they are still referenced
        by viewports, which are not destroyed during this process.
    */
    void ClearScene();
    /// sets the ambient light level to be used for the scene
    /**
        @remarks
            This sets the colour and intensity of the ambient light in the scene, i.e. the
            light which is 'sourceless' and illuminates all objects equally.
            The colour of an object is affected by a combination of the light in the scene,
            and the amount of light that object reflects (in this case based on the Material::ambient
            property).
        @remarks
            By default the ambient light in the scene is 0x00000000, i.e. no ambient light. This
            means that any objects rendered with a Material which has lighting enabled (see Material::SetLightingEnabled)
            will not be visible unless you have some dynamic lights in your scene.
    */
    void SetAmbientLight(unsigned int colour);
    /// returns the ambient light level to be used for the scene.
    const unsigned int GetAmbientLight() const;
    /// sets the general shadow technique to be used in this scene
    void SetShadowTechnique(ShadowTechnique technique);
    /// gets the current shadow technique
    ShadowTechnique GetShadowTechnique() const;
    /// is there any shadowing technique in use?
    bool IsShadowTechniqueInUse() const;
    /// method for preparing shadow textures ready for use in a regular render
    void PrepareShadowTextures();
    /// prompts the class to send its contents to the renderer
    void _RenderScene(Camera *camera, Viewport *vp); 
    /// internal method for setting up the renderstate for a rendering pass
    void _SetPass(Pass* pass);

private:
    /// render the objects in a given queue group 
    void _RenderQueueGroupObjects(QueuedRenderableCollection* queue);
    /// render a group rendering only shadow receivers
    void _RenderTextureShadowReceiverQueueGroupObjects(QueuedRenderableCollection* queue);
    /// copy constructor
    SceneManager(const SceneManager&cc) {}; 

    static SceneManager* Singleton;
    
    HashTable cameras;
    
    LinkedList* movableObjectCollectionMap;
 
    /// central list of SceneNodes - for easy memory management 
    LinkedList* sceneNodes;
    /// root scene node
    SceneNode* sceneRoot;

    /// current ambient light, cached for RenderSystem
    unsigned int ambientLight;
    /// The rendering system to send the scene to
    RenderSystem* destRenderSystem;

    /// renderqueues
    QueuedRenderableCollection renderQueueOpaque;
    QueuedRenderableCollection renderQueueTransparent;
    QueuedRenderableCollection renderQueueShadowCaster;
    QueuedRenderableCollection renderQueueShadowReceiver;

    /// shadow related members
    IlluminationRenderStage illuminationStage;
    ShadowTechnique shadowTechnique;
    bool shadowTextureConfigDirty;
    
    Texture* shadowTexture;
    RenderTexture* shadowRenderTexture;
    Camera* shadowCamera;
    Pass* shadowRttPass;
    Pass* shadowPass;
    core::Matrix4 shadowTextureProjScaleTrans;
    core::Matrix4 shadowProjection;
};

} // namespace graphics
} // namespace chrissly
//------------------------------------------------------------------------------
#endif
