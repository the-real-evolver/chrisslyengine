#ifndef D3D11DEFAULTSHADERS_H_
#define D3D11DEFAULTSHADERS_H_
//------------------------------------------------------------------------------
/**
    Default shader variations for the Direct3D 11 rendersystem

    (C) 2016 Christian Bleicher
*/

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgram =
    "#ifndef NO_TEXTURE\n"
    "Texture2D texture0 : register(t0);\n"
    "#endif\n"
    "SamplerState samplerLinear : register(s0);\n"
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "};\n"
    "cbuffer DefaultConstantBuffer : register(b1)\n"
    "{\n"
    "#ifdef NO_TEXTURE\n"
    "    float4 ambient;\n"
    "#else\n"
    "    float1 uMod;\n"
    "    float1 vMod;\n"
    "    float1 uScale;\n"
    "    float1 vScale;\n"
    "#endif\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float2 uv : TEXCOORD;\n"
    "    float4 position : SV_Position;\n"
    "    float4 colour : COLOR;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    output.uv = input.uv;\n"
    "    output.position = mul(float4(input.position, 1.0f), worldViewProjMatrix);\n"
    "    output.colour = input.colour;\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "#ifdef NO_TEXTURE\n"
    "    output = ambient;\n"
    "#else\n"
    "    output = texture0.Sample(samplerLinear, float2(uScale * input.uv.x + uMod, vScale * input.uv.y + vMod));\n"
    "#endif\n"
    "};\n";

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgramFog =
    "#ifndef NO_TEXTURE\n"
    "Texture2D texture0 : register(t0);\n"
    "#endif\n"
    "SamplerState samplerLinear : register(s0);\n"
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "    matrix worldMatrix;\n"
    "};\n"
    "cbuffer DefaultConstantBuffer : register(b1)\n"
    "{\n"
    "    matrix viewMatrix;\n"
    "#ifdef NO_TEXTURE\n"
    "    float4 ambient;\n"
    "#else\n"
    "    float1 uMod;\n"
    "    float1 vMod;\n"
    "    float1 uScale;\n"
    "    float1 vScale;\n"
    "#endif\n"
    "    int fogMode;\n"
    "    float1 fogStart;\n"
    "    float1 fogEnd;\n"
    "    float3 fogColour;\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float2 uv : TEXCOORD;\n"
    "    float4 position : SV_Position;\n"
    "    float4 colour : COLOR;\n"
    "    float1 fogFactor : FOG;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    output.uv = input.uv;\n"
    "    output.position = mul(float4(input.position, 1.0f), worldViewProjMatrix);\n"
    "    output.colour = input.colour;\n"
    "    if (1 == fogMode)\n"
    "    {\n"
    "        // range based linear fog\n"
    "        output.fogFactor = clamp((fogEnd - length(mul(mul(float4(input.position, 1.0f), worldMatrix), viewMatrix))) / (fogEnd - fogStart), 0.0f, 1.0f);\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        output.fogFactor = 1.0f;\n"
    "    }\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "#ifdef NO_TEXTURE\n"
    "    output = lerp(float4(fogColour, 1.0f), ambient, input.fogFactor.x);\n"
    "#else\n"
    "    output = lerp(float4(fogColour, 1.0f), texture0.Sample(samplerLinear, float2(uScale * input.uv.x + uMod, vScale * input.uv.y + vMod)), input.fogFactor.x);\n"
    "#endif\n"
    "};\n";

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgramLit =
    "#ifndef NO_TEXTURE\n"
    "Texture2D texture0 : register(t0);\n"
    "#endif\n"
    "SamplerState samplerLinear : register(s0);\n"
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "    matrix worldMatrix;\n"
    "};\n"
    "cbuffer DefaultConstantBuffer : register(b1)\n"
    "{\n"
    "#ifdef NO_TEXTURE\n"
    "    float4 ambient;\n"
    "#else\n"
    "    float1 uMod;\n"
    "    float1 vMod;\n"
    "    float1 uScale;\n"
    "    float1 vScale;\n"
    "#endif\n"
    "    float3 cameraPosition;\n"
    "    matrix lightParams[4];\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float2 uv : TEXCOORD;\n"
    "    float4 position : SV_Position;\n"
    "    float4 colour : COLOR;\n"
    "    float3 worldNormal : NORMAL;\n"
    "    float3 worldPosition : POSITION;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    output.uv = input.uv;\n"
    "    output.position = mul(float4(input.position, 1.0f), worldViewProjMatrix);\n"
    "    output.colour = input.colour;\n"
    "    output.worldNormal = normalize(mul(input.normal, float3x3(worldMatrix[0].xyz, worldMatrix[1].xyz, worldMatrix[2].xyz)));\n"
    "    output.worldPosition = mul(float4(input.position.xyz, 1.0f), worldMatrix).xyz;\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "    float4 colour;\n"
    "#ifdef NO_TEXTURE\n"
    "    colour = ambient;\n"
    "#else\n"
    "    colour = texture0.Sample(samplerLinear, float2(uScale * input.uv.x + uMod, vScale * input.uv.y + vMod));\n"
    "#endif\n"
    "    float3 L;\n"
    "    float3 diffuse = {0.0f, 0.0f, 0.0f};\n"
    "    float3 specular = {0.0f, 0.0f, 0.0f};\n"
    "    for (int i = 0; i < 4; ++i)\n"
    "    {\n"
    "        L = normalize(float3(lightParams[i][0][0], lightParams[i][1][0], lightParams[i][2][0]) - input.worldPosition);\n"
    "        float distance = length(float3(lightParams[i][0][0], lightParams[i][1][0], lightParams[i][2][0]) - input.worldPosition);\n"
    "        float attenuation = 1.0f / (lightParams[i][0][3] + lightParams[i][1][3] * distance + lightParams[i][2][3] * (distance * distance));\n"
    "        if (distance > lightParams[i][3][3]) {attenuation = 0.0f;};\n"
    "        diffuse += mul(mul(float3(lightParams[i][0][1], lightParams[i][1][1], lightParams[i][2][1]), max(0.0f, dot(L, normalize(input.worldNormal)))), attenuation);\n"
    "        float specFactor = pow(max(0.0f, dot(reflect(-L, normalize(input.worldNormal)), normalize(cameraPosition - input.worldPosition))), lightParams[i][3][2]);\n"
    "        specular += mul(mul(float3(lightParams[i][0][2], lightParams[i][1][2], lightParams[i][2][2]), specFactor), attenuation);\n"
    "    }\n"
    "    colour.rgb = clamp(colour.rgb * (diffuse + specular), 0.0f, 1.0f);\n"
    "    output = colour;\n"
    "};\n";

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgramLitFog =
    "#ifndef NO_TEXTURE\n"
    "Texture2D texture0 : register(t0);\n"
    "#endif\n"
    "SamplerState samplerLinear : register(s0);\n"
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "    matrix worldMatrix;\n"
    "};\n"
    "cbuffer DefaultConstantBuffer : register(b1)\n"
    "{\n"
    "    matrix viewMatrix;\n"
    "#ifdef NO_TEXTURE\n"
    "    float4 ambient;\n"
    "#else\n"
    "    float1 uMod;\n"
    "    float1 vMod;\n"
    "    float1 uScale;\n"
    "    float1 vScale;\n"
    "#endif\n"
    "    int fogMode;\n"
    "    float1 fogStart;\n"
    "    float1 fogEnd;\n"
    "    float3 fogColour;\n"
    "    float3 cameraPosition;\n"
    "    matrix lightParams[4];\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float2 uv : TEXCOORD;\n"
    "    float4 position : SV_Position;\n"
    "    float4 colour : COLOR;\n"
    "    float1 fogFactor : FOG;\n"
    "    float3 worldNormal : NORMAL;\n"
    "    float3 worldPosition : POSITION;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    output.uv = input.uv;\n"
    "    output.position = mul(float4(input.position, 1.0f), worldViewProjMatrix);\n"
    "    output.colour = input.colour;\n"
    "    if (1 == fogMode)\n"
    "    {\n"
    "        // range based linear fog\n"
    "        output.fogFactor = clamp((fogEnd - length(mul(mul(float4(input.position, 1.0f), worldMatrix), viewMatrix))) / (fogEnd - fogStart), 0.0f, 1.0f);\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        output.fogFactor = 1.0f;\n"
    "    }\n"
    "    output.worldNormal = normalize(mul(input.normal, float3x3(worldMatrix[0].xyz, worldMatrix[1].xyz, worldMatrix[2].xyz)));\n"
    "    output.worldPosition = mul(float4(input.position.xyz, 1.0f), worldMatrix).xyz;\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "    float4 colour;\n"
    "#ifdef NO_TEXTURE\n"
    "    colour = ambient;\n"
    "#else\n"
    "    colour = texture0.Sample(samplerLinear, float2(uScale * input.uv.x + uMod, vScale * input.uv.y + vMod));\n"
    "#endif\n"
    "    float3 L;\n"
    "    float3 diffuse = {0.0f, 0.0f, 0.0f};\n"
    "    float3 specular = {0.0f, 0.0f, 0.0f};\n"
    "    for (int i = 0; i < 4; ++i)\n"
    "    {\n"
    "        L = normalize(float3(lightParams[i][0][0], lightParams[i][1][0], lightParams[i][2][0]) - input.worldPosition);\n"
    "        float distance = length(float3(lightParams[i][0][0], lightParams[i][1][0], lightParams[i][2][0]) - input.worldPosition);\n"
    "        float attenuation = 1.0f / (lightParams[i][0][3] + lightParams[i][1][3] * distance + lightParams[i][2][3] * (distance * distance));\n"
    "        if (distance > lightParams[i][3][3]) {attenuation = 0.0f;};\n"
    "        diffuse += mul(mul(float3(lightParams[i][0][1], lightParams[i][1][1], lightParams[i][2][1]), max(0.0f, dot(L, normalize(input.worldNormal)))), attenuation);\n"
    "        float specFactor = pow(max(0.0f, dot(reflect(-L, normalize(input.worldNormal)), normalize(cameraPosition - input.worldPosition))), lightParams[i][3][2]);\n"
    "        specular += mul(mul(float3(lightParams[i][0][2], lightParams[i][1][2], lightParams[i][2][2]), specFactor), attenuation);\n"
    "    }\n"
    "    colour.rgb = clamp(colour.rgb * (diffuse + specular), 0.0f, 1.0f);\n"
    "    output = lerp(float4(fogColour, 1.0f), colour, input.fogFactor.x);\n"
    "};\n";

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgramMorphAnim =
    "#ifndef NO_TEXTURE\n"
    "Texture2D texture0 : register(t0);\n"
    "#endif\n"
    "SamplerState samplerLinear : register(s0);\n"
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "    matrix worldMatrix;\n"
    "    float1 morphWeight;\n"
    "};\n"
    "cbuffer DefaultConstantBuffer : register(b1)\n"
    "{\n"
    "#ifdef NO_TEXTURE\n"
    "    float4 ambient;\n"
    "#else\n"
    "    float1 uMod;\n"
    "    float1 vMod;\n"
    "    float1 uScale;\n"
    "    float1 vScale;\n"
    "#endif\n"
    "    float3 cameraPosition;\n"
    "    matrix lightParams[4];\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "    float2 uvMorphTarget : TEXCOORD1;\n"
    "    float3 normalMorphTarget : NORMAL1;\n"
    "    float3 positionMorphTarget : POSITION1;\n"
    "    float4 colourTarget : COLOR1;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float2 uv : TEXCOORD;\n"
    "    float4 position : SV_Position;\n"
    "    float4 colour : COLOR;\n"
    "    float3 worldNormal : NORMAL;\n"
    "    float3 worldPosition : POSITION;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    output.uv = input.uv + (input.uvMorphTarget - input.uv) * morphWeight;\n"
    "    output.position = mul(float4((input.position + (input.positionMorphTarget - input.position) * morphWeight), 1.0f), worldViewProjMatrix);\n"
    "    output.colour = input.colour;\n"
    "    output.worldNormal = normalize(mul(input.normal + (input.normalMorphTarget - input.normal) * morphWeight, float3x3(worldMatrix[0].xyz, worldMatrix[1].xyz, worldMatrix[2].xyz)));\n"
    "    output.worldPosition = mul(float4(input.position + (input.positionMorphTarget - input.position) * morphWeight, 1.0f), worldMatrix).xyz;\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "    float4 colour;\n"
    "#ifdef NO_TEXTURE\n"
    "    colour = ambient;\n"
    "#else\n"
    "    colour = texture0.Sample(samplerLinear, float2(uScale * input.uv.x + uMod, vScale * input.uv.y + vMod));\n"
    "#endif\n"
    "    float3 L;\n"
    "    float3 diffuse = {0.0f, 0.0f, 0.0f};\n"
    "    float3 specular = {0.0f, 0.0f, 0.0f};\n"
    "    for (int i = 0; i < 4; ++i)\n"
    "    {\n"
    "        L = normalize(float3(lightParams[i][0][0], lightParams[i][1][0], lightParams[i][2][0]) - input.worldPosition);\n"
    "        float distance = length(float3(lightParams[i][0][0], lightParams[i][1][0], lightParams[i][2][0]) - input.worldPosition);\n"
    "        float attenuation = 1.0f / (lightParams[i][0][3] + lightParams[i][1][3] * distance + lightParams[i][2][3] * (distance * distance));\n"
    "        if (distance > lightParams[i][3][3]) {attenuation = 0.0f;};\n"
    "        diffuse += mul(mul(float3(lightParams[i][0][1], lightParams[i][1][1], lightParams[i][2][1]), max(0.0f, dot(L, normalize(input.worldNormal)))), attenuation);\n"
    "        float specFactor = pow(max(0.0f, dot(reflect(-L, normalize(input.worldNormal)), normalize(cameraPosition - input.worldPosition))), lightParams[i][3][2]);\n"
    "        specular += mul(mul(float3(lightParams[i][0][2], lightParams[i][1][2], lightParams[i][2][2]), specFactor), attenuation);\n"
    "    }\n"
    "    colour.rgb = clamp(colour.rgb * (diffuse + specular), 0.0f, 1.0f);\n"
    "    output = colour;\n"
    "};\n";

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgramSkeletalAnim =
    "#ifndef NO_TEXTURE\n"
    "Texture2D texture0 : register(t0);\n"
    "#endif\n"
    "SamplerState samplerLinear : register(s0);\n"
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "    matrix worldMatrix;\n"
    "};\n"
    "cbuffer DefaultConstantBuffer : register(b1)\n"
    "{\n"
    "#ifdef NO_TEXTURE\n"
    "    float4 ambient;\n"
    "#else\n"
    "    float1 uMod;\n"
    "    float1 vMod;\n"
    "    float1 uScale;\n"
    "    float1 vScale;\n"
    "#endif\n"
    "    matrix boneMatrices[12];\n"
    "    float3 cameraPosition;\n"
    "    matrix lightParams[4];\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float4 weights0 : BLENDWEIGHT0;\n"
    "    float4 weights1 : BLENDWEIGHT1;\n"
    "    float4 weights2 : BLENDWEIGHT2;\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float2 uv : TEXCOORD;\n"
    "    float4 position : SV_Position;\n"
    "    float4 colour : COLOR;\n"
    "    float3 worldNormal : NORMAL;\n"
    "    float3 worldPosition : POSITION;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    float3 P = input.position;\n"
    "    float3 N = input.normal;\n"
    "    if (any(input.weights0) || any(input.weights1) || any(input.weights2))\n"
    "    {\n"
    "        matrix m = 0.0f;\n"
    "        for (int i = 0; i < 4; ++i)\n"
    "        {\n"
    "            m += boneMatrices[i] * input.weights0[i];\n"
    "            m += boneMatrices[i + 4] * input.weights1[i];\n"
    "            m += boneMatrices[i + 8] * input.weights2[i];\n"
    "        }\n"
    "        P = mul(float4(P, 1.0f), m).xyz;\n"
    "        N = normalize(mul(N, float3x3(m[0].xyz, m[1].xyz, m[2].xyz)));\n"
    "    }\n"
    "    P = float3(P.x, P.z, -P.y);\n"
    "    N = float3(N.x, N.z, -N.y);\n"
    "    output.uv = input.uv;\n"
    "    output.position = mul(float4(P, 1.0f), worldViewProjMatrix);\n"
    "    output.colour = input.colour;\n"
    "    output.worldNormal = normalize(mul(N, float3x3(worldMatrix[0].xyz, worldMatrix[1].xyz, worldMatrix[2].xyz)));\n"
    "    output.worldPosition = mul(float4(P, 1.0f), worldMatrix).xyz;\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "    float4 colour;\n"
    "#ifdef NO_TEXTURE\n"
    "    colour = ambient;\n"
    "#else\n"
    "    colour = texture0.Sample(samplerLinear, float2(uScale * input.uv.x + uMod, vScale * input.uv.y + vMod));\n"
    "#endif\n"
    "    float3 L;\n"
    "    float3 diffuse = {0.0f, 0.0f, 0.0f};\n"
    "    float3 specular = {0.0f, 0.0f, 0.0f};\n"
    "    for (int i = 0; i < 4; ++i)\n"
    "    {\n"
    "        L = normalize(float3(lightParams[i][0][0], lightParams[i][1][0], lightParams[i][2][0]) - input.worldPosition);\n"
    "        float distance = length(float3(lightParams[i][0][0], lightParams[i][1][0], lightParams[i][2][0]) - input.worldPosition);\n"
    "        float attenuation = 1.0f / (lightParams[i][0][3] + lightParams[i][1][3] * distance + lightParams[i][2][3] * (distance * distance));\n"
    "        if (distance > lightParams[i][3][3]) {attenuation = 0.0f;};\n"
    "        diffuse += mul(mul(float3(lightParams[i][0][1], lightParams[i][1][1], lightParams[i][2][1]), max(0.0f, dot(L, normalize(input.worldNormal)))), attenuation);\n"
    "        float specFactor = pow(max(0.0f, dot(reflect(-L, normalize(input.worldNormal)), normalize(cameraPosition - input.worldPosition))), lightParams[i][3][2]);\n"
    "        specular += mul(mul(float3(lightParams[i][0][2], lightParams[i][1][2], lightParams[i][2][2]), specFactor), attenuation);\n"
    "    }\n"
    "    colour.rgb = clamp(colour.rgb * (diffuse + specular), 0.0f, 1.0f);\n"
    "    output = colour;\n"
    "};\n";

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgramShadowCaster =
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float4 position : SV_Position;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    output.position = mul(float4(input.position, 1.0f), worldViewProjMatrix);\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "    output = float4(0.5, 0.5, 0.5, 1.0);\n"
    "};\n";

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgramTransparentShadowCaster =
    "Texture2D texture0 : register(t0);\n"
    "SamplerState samplerLinear : register(s0);\n"
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float2 uv : TEXCOORD;\n"
    "    float4 position : SV_Position;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    output.uv = input.uv;\n"
    "    output.position = mul(float4(input.position, 1.0f), worldViewProjMatrix);\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "    output = float4(0.5, 0.5, 0.5, texture0.Sample(samplerLinear, input.uv).a);\n"
    "};\n";

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgramShadowReceiver =
    "Texture2D texture0 : register(t0);\n"
    "SamplerState samplerLinear : register(s0);\n"
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "    matrix textureMatrix;\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float4 uv : TEXCOORD;\n"
    "    float4 position : SV_Position;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    output.uv = mul(float4(input.position, 1.0f), textureMatrix);\n"
    "    output.position = mul(float4(input.position, 1.0f), worldViewProjMatrix);\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "    float4 colour = {1.0f, 1.0f, 1.0f, 1.0f};\n"
    "    if (input.uv.w > 0.0f)\n"
    "    {\n"
    "        colour = texture0.Sample(samplerLinear, input.uv.xy / input.uv.w);\n"
    "    }\n"
    "    output = colour;"
    "};\n";

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgramShadowCasterMorphAnim =
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "    float1 morphWeight;\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "    float2 uvTarget : TEXCOORD1;\n"
    "    float3 normalTarget : NORMAL1;\n"
    "    float3 positionMorphTarget : POSITION1;\n"
    "    float4 colourTarget : COLOR1;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float4 position : SV_Position;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    output.position = mul(float4((input.position + (input.positionMorphTarget - input.position) * morphWeight), 1.0f), worldViewProjMatrix);\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "    output = float4(0.5, 0.5, 0.5, 1.0);\n"
    "};\n";

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgramTransparentShadowCasterMorphAnim =
    "Texture2D texture0 : register(t0);\n"
    "SamplerState samplerLinear : register(s0);\n"
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "    float1 morphWeight;\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "    float2 uvMorphTarget : TEXCOORD1;\n"
    "    float3 normalTarget : NORMAL1;\n"
    "    float3 positionMorphTarget : POSITION1;\n"
    "    float4 colourTarget : COLOR1;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float2 uv : TEXCOORD;\n"
    "    float4 position : SV_Position;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    output.uv = input.uv + (input.uvMorphTarget - input.uv) * morphWeight;\n"
    "    output.position = mul(float4((input.position + (input.positionMorphTarget - input.position) * morphWeight), 1.0f), worldViewProjMatrix);\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "    output = float4(0.5, 0.5, 0.5, texture0.Sample(samplerLinear, input.uv).a);\n"
    "};\n";
//------------------------------------------------------------------------------
#endif