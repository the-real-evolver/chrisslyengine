#ifndef D3D11DEFAULTSHADERS_H_
#define D3D11DEFAULTSHADERS_H_
//------------------------------------------------------------------------------
/**
    Default shader variations for the Direct3D 11 rendersystem

    (C) 2016 Christian Bleicher
*/

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgram =
    "#ifndef NO_TEXTURE\n"
    "Texture2D texture0 : register(t0);\n"
    "SamplerState samplerLinear : register(s0);\n"
    "#endif\n"
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "};\n"
    "cbuffer DefaultConstantBuffer : register(b1)\n"
    "{\n"
    "#ifdef NO_TEXTURE\n"
    "    float4 ambient;\n"
    "#else\n"
    "    float1 uMod;\n"
    "    float1 vMod;\n"
    "    float1 uScale;\n"
    "    float1 vScale;\n"
    "#endif\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float2 uv : TEXCOORD;\n"
    "    float4 position : SV_Position;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    output.uv = input.uv;\n"
    "    output.position = mul(float4(input.position, 1.0f), worldViewProjMatrix);\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "#ifdef NO_TEXTURE\n"
    "    output = ambient;\n"
    "#else\n"
    "    output = texture0.Sample(samplerLinear, float2(uScale * input.uv.x + uMod, vScale * input.uv.y + vMod));\n"
    "#endif\n"
    "};\n";

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgramFog =
    "#define FOG_LINEAR 1\n"
    "#ifndef NO_TEXTURE\n"
    "Texture2D texture0 : register(t0);\n"
    "SamplerState samplerLinear : register(s0);\n"
    "#endif\n"
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "    matrix worldMatrix;\n"
    "};\n"
    "cbuffer DefaultConstantBuffer : register(b1)\n"
    "{\n"
    "    matrix viewMatrix;\n"
    "#ifdef NO_TEXTURE\n"
    "    float4 ambient;\n"
    "#else\n"
    "    float1 uMod;\n"
    "    float1 vMod;\n"
    "    float1 uScale;\n"
    "    float1 vScale;\n"
    "#endif\n"
    "    int fogMode;\n"
    "    float1 fogStart;\n"
    "    float1 fogEnd;\n"
    "    float3 fogColour;\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float2 uv : TEXCOORD;\n"
    "    float4 position : SV_Position;\n"
    "    float1 fogFactor : FOG;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    output.uv = input.uv;\n"
    "    output.position = mul(float4(input.position, 1.0f), worldViewProjMatrix);\n"
    "    if (FOG_LINEAR == fogMode)\n"
    "    {\n"
    "        // range based linear fog\n"
    "        output.fogFactor = clamp((fogEnd - length(mul(mul(float4(input.position, 1.0f), worldMatrix), viewMatrix))) / (fogEnd - fogStart), 0.0f, 1.0f);\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        output.fogFactor = 1.0f;\n"
    "    }\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "#ifdef NO_TEXTURE\n"
    "    output = lerp(float4(fogColour, 1.0f), ambient, input.fogFactor.x);\n"
    "#else\n"
    "    output = lerp(float4(fogColour, 1.0f), texture0.Sample(samplerLinear, float2(uScale * input.uv.x + uMod, vScale * input.uv.y + vMod)), input.fogFactor.x);\n"
    "#endif\n"
    "};\n";

//------------------------------------------------------------------------------
/**
    Normal-Mapping without precomputed tangents see:
    http://www.thetenthplanet.de/archives/1180
*/
const char* const DefaultGpuProgramLit =
    "#define MaxLights 4\n"
    "#ifndef NO_TEXTURE\n"
    "Texture2D texture0 : register(t0);\n"
    "#ifdef USE_NORMALMAP\n"
    "Texture2D normalMap : register(t1);\n"
    "#endif\n"
    "SamplerState samplerLinear : register(s0);\n"
    "#endif\n"
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "    matrix worldMatrix;\n"
    "};\n"
    "cbuffer DefaultConstantBuffer : register(b1)\n"
    "{\n"
    "#ifdef NO_TEXTURE\n"
    "    float4 ambient;\n"
    "#else\n"
    "    float1 uMod;\n"
    "    float1 vMod;\n"
    "    float1 uScale;\n"
    "    float1 vScale;\n"
    "#endif\n"
    "    float3 cameraPosition;\n"
    "    matrix lightParams[4];\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float2 uv : TEXCOORD;\n"
    "    float4 position : SV_Position;\n"
    "    float3 worldNormal : NORMAL;\n"
    "    float3 worldPosition : POSITION;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    output.uv = input.uv;\n"
    "    output.position = mul(float4(input.position, 1.0f), worldViewProjMatrix);\n"
    "    output.worldNormal = normalize(mul(input.normal, float3x3(worldMatrix[0].xyz, worldMatrix[1].xyz, worldMatrix[2].xyz)));\n"
    "    output.worldPosition = mul(float4(input.position.xyz, 1.0f), worldMatrix).xyz;\n"
    "}\n"
    "#ifndef NO_TEXTURE\n"
    "#ifdef USE_NORMALMAP\n"
    "float3x3 CotangentFrame(float3 N, float3 p, float2 uv)\n"
    "{\n"
    "   // get edge vectors of the pixel triangle\n"
    "   float3 dp1 = ddx(p);\n"
    "   float3 dp2 = ddy(p);\n"
    "   float2 duv1 = ddx(uv);\n"
    "   float2 duv2 = ddy(uv);\n"
    "   // solve the linear system\n"
    "   float3 dp2perp = cross(dp2, N);\n"
    "   float3 dp1perp = cross(N, dp1);\n"
    "   float3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n"
    "   float3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n"
    "   // construct a scale-invariant frame\n"
    "   float invmax = rsqrt(max(dot(T, T), dot(B, B)));\n"
    "   return float3x3(T * invmax, B * invmax, N);\n"
    "}\n"
    "float3 PerturbNormal(float3 N, float3 V, float2 texcoord)\n"
    "{\n"
    "   // assume N, the interpolated vertex normal and V, the view vector (vertex to eye)\n"
    "   float3 map = normalMap.Sample(samplerLinear, texcoord).xyz;\n"
    "   float3x3 TBN = CotangentFrame(N, -V, texcoord);\n"
    "   return normalize(mul(map, TBN));\n"
    "}\n"
    "#endif\n"
    "#endif\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "    float4 colour;\n"
    "    float3 N;\n"
    "#ifdef NO_TEXTURE\n"
    "    colour = ambient;\n"
    "    N = input.worldNormal;\n"
    "#else\n"
    "    colour = texture0.Sample(samplerLinear, float2(uScale * input.uv.x + uMod, vScale * input.uv.y + vMod));\n"
    "#ifdef USE_NORMALMAP\n"
    "    N = PerturbNormal(normalize(input.worldNormal), normalize(input.worldPosition - cameraPosition), input.uv);\n"
    "#else\n"
    "    N = input.worldNormal;\n"
    "#endif\n"
    "#endif\n"
    "    float3 L;\n"
    "    float3 diffuse = {0.0f, 0.0f, 0.0f};\n"
    "    float3 specular = {0.0f, 0.0f, 0.0f};\n"
    "    for (int i = 0; i < MaxLights; ++i)\n"
    "    {\n"
    "        L = normalize(float3(lightParams[i][0][0], lightParams[i][1][0], lightParams[i][2][0]) - input.worldPosition);\n"
    "        float distance = length(float3(lightParams[i][0][0], lightParams[i][1][0], lightParams[i][2][0]) - input.worldPosition);\n"
    "        float attenuation = 1.0f / (lightParams[i][0][3] + lightParams[i][1][3] * distance + lightParams[i][2][3] * (distance * distance));\n"
    "        if (distance > lightParams[i][3][3]) {attenuation = 0.0f;};\n"
    "        diffuse += mul(mul(float3(lightParams[i][0][1], lightParams[i][1][1], lightParams[i][2][1]), max(0.0f, dot(L, normalize(N)))), attenuation);\n"
    "        float specFactor = pow(max(0.0f, dot(reflect(-L, normalize(N)), normalize(cameraPosition - input.worldPosition))), lightParams[i][3][2]);\n"
    "        specular += mul(mul(float3(lightParams[i][0][2], lightParams[i][1][2], lightParams[i][2][2]), specFactor), attenuation);\n"
    "    }\n"
    "    colour.rgb = clamp(colour.rgb * (diffuse + specular), 0.0f, 1.0f);\n"
    "    output = colour;\n"
    "};\n";

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgramLitFog =
    "#define MaxLights 4\n"
    "#define FOG_LINEAR 1\n"
    "#ifndef NO_TEXTURE\n"
    "Texture2D texture0 : register(t0);\n"
    "SamplerState samplerLinear : register(s0);\n"
    "#endif\n"
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "    matrix worldMatrix;\n"
    "};\n"
    "cbuffer DefaultConstantBuffer : register(b1)\n"
    "{\n"
    "    matrix viewMatrix;\n"
    "#ifdef NO_TEXTURE\n"
    "    float4 ambient;\n"
    "#else\n"
    "    float1 uMod;\n"
    "    float1 vMod;\n"
    "    float1 uScale;\n"
    "    float1 vScale;\n"
    "#endif\n"
    "    int fogMode;\n"
    "    float1 fogStart;\n"
    "    float1 fogEnd;\n"
    "    float3 fogColour;\n"
    "    float3 cameraPosition;\n"
    "    matrix lightParams[4];\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float2 uv : TEXCOORD;\n"
    "    float4 position : SV_Position;\n"
    "    float1 fogFactor : FOG;\n"
    "    float3 worldNormal : NORMAL;\n"
    "    float3 worldPosition : POSITION;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    output.uv = input.uv;\n"
    "    output.position = mul(float4(input.position, 1.0f), worldViewProjMatrix);\n"
    "    if (FOG_LINEAR == fogMode)\n"
    "    {\n"
    "        // range based linear fog\n"
    "        output.fogFactor = clamp((fogEnd - length(mul(mul(float4(input.position, 1.0f), worldMatrix), viewMatrix))) / (fogEnd - fogStart), 0.0f, 1.0f);\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        output.fogFactor = 1.0f;\n"
    "    }\n"
    "    output.worldNormal = normalize(mul(input.normal, float3x3(worldMatrix[0].xyz, worldMatrix[1].xyz, worldMatrix[2].xyz)));\n"
    "    output.worldPosition = mul(float4(input.position.xyz, 1.0f), worldMatrix).xyz;\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "    float4 colour;\n"
    "#ifdef NO_TEXTURE\n"
    "    colour = ambient;\n"
    "#else\n"
    "    colour = texture0.Sample(samplerLinear, float2(uScale * input.uv.x + uMod, vScale * input.uv.y + vMod));\n"
    "#endif\n"
    "    float3 L;\n"
    "    float3 diffuse = {0.0f, 0.0f, 0.0f};\n"
    "    float3 specular = {0.0f, 0.0f, 0.0f};\n"
    "    for (int i = 0; i < MaxLights; ++i)\n"
    "    {\n"
    "        L = normalize(float3(lightParams[i][0][0], lightParams[i][1][0], lightParams[i][2][0]) - input.worldPosition);\n"
    "        float distance = length(float3(lightParams[i][0][0], lightParams[i][1][0], lightParams[i][2][0]) - input.worldPosition);\n"
    "        float attenuation = 1.0f / (lightParams[i][0][3] + lightParams[i][1][3] * distance + lightParams[i][2][3] * (distance * distance));\n"
    "        if (distance > lightParams[i][3][3]) {attenuation = 0.0f;};\n"
    "        diffuse += mul(mul(float3(lightParams[i][0][1], lightParams[i][1][1], lightParams[i][2][1]), max(0.0f, dot(L, normalize(input.worldNormal)))), attenuation);\n"
    "        float specFactor = pow(max(0.0f, dot(reflect(-L, normalize(input.worldNormal)), normalize(cameraPosition - input.worldPosition))), lightParams[i][3][2]);\n"
    "        specular += mul(mul(float3(lightParams[i][0][2], lightParams[i][1][2], lightParams[i][2][2]), specFactor), attenuation);\n"
    "    }\n"
    "    colour.rgb = clamp(colour.rgb * (diffuse + specular), 0.0f, 1.0f);\n"
    "    output = lerp(float4(fogColour, 1.0f), colour, input.fogFactor.x);\n"
    "};\n";

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgramMorphAnim =
    "#define MaxLights 4\n"
    "#ifndef NO_TEXTURE\n"
    "Texture2D texture0 : register(t0);\n"
    "SamplerState samplerLinear : register(s0);\n"
    "#endif\n"
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "    matrix worldMatrix;\n"
    "    float1 morphWeight;\n"
    "};\n"
    "cbuffer DefaultConstantBuffer : register(b1)\n"
    "{\n"
    "#ifdef NO_TEXTURE\n"
    "    float4 ambient;\n"
    "#else\n"
    "    float1 uMod;\n"
    "    float1 vMod;\n"
    "    float1 uScale;\n"
    "    float1 vScale;\n"
    "#endif\n"
    "    float3 cameraPosition;\n"
    "    matrix lightParams[4];\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "    float2 uvMorphTarget : TEXCOORD1;\n"
    "    float3 normalMorphTarget : NORMAL1;\n"
    "    float3 positionMorphTarget : POSITION1;\n"
    "    float4 colourTarget : COLOR1;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float2 uv : TEXCOORD;\n"
    "    float4 position : SV_Position;\n"
    "    float3 worldNormal : NORMAL;\n"
    "    float3 worldPosition : POSITION;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    output.uv = input.uv + (input.uvMorphTarget - input.uv) * morphWeight;\n"
    "    output.position = mul(float4((input.position + (input.positionMorphTarget - input.position) * morphWeight), 1.0f), worldViewProjMatrix);\n"
    "    output.worldNormal = normalize(mul(input.normal + (input.normalMorphTarget - input.normal) * morphWeight, float3x3(worldMatrix[0].xyz, worldMatrix[1].xyz, worldMatrix[2].xyz)));\n"
    "    output.worldPosition = mul(float4(input.position + (input.positionMorphTarget - input.position) * morphWeight, 1.0f), worldMatrix).xyz;\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "    float4 colour;\n"
    "#ifdef NO_TEXTURE\n"
    "    colour = ambient;\n"
    "#else\n"
    "    colour = texture0.Sample(samplerLinear, float2(uScale * input.uv.x + uMod, vScale * input.uv.y + vMod));\n"
    "#endif\n"
    "    float3 L;\n"
    "    float3 diffuse = {0.0f, 0.0f, 0.0f};\n"
    "    float3 specular = {0.0f, 0.0f, 0.0f};\n"
    "    for (int i = 0; i < MaxLights; ++i)\n"
    "    {\n"
    "        L = normalize(float3(lightParams[i][0][0], lightParams[i][1][0], lightParams[i][2][0]) - input.worldPosition);\n"
    "        float distance = length(float3(lightParams[i][0][0], lightParams[i][1][0], lightParams[i][2][0]) - input.worldPosition);\n"
    "        float attenuation = 1.0f / (lightParams[i][0][3] + lightParams[i][1][3] * distance + lightParams[i][2][3] * (distance * distance));\n"
    "        if (distance > lightParams[i][3][3]) {attenuation = 0.0f;};\n"
    "        diffuse += mul(mul(float3(lightParams[i][0][1], lightParams[i][1][1], lightParams[i][2][1]), max(0.0f, dot(L, normalize(input.worldNormal)))), attenuation);\n"
    "        float specFactor = pow(max(0.0f, dot(reflect(-L, normalize(input.worldNormal)), normalize(cameraPosition - input.worldPosition))), lightParams[i][3][2]);\n"
    "        specular += mul(mul(float3(lightParams[i][0][2], lightParams[i][1][2], lightParams[i][2][2]), specFactor), attenuation);\n"
    "    }\n"
    "    colour.rgb = clamp(colour.rgb * (diffuse + specular), 0.0f, 1.0f);\n"
    "    output = colour;\n"
    "};\n";

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgramSkeletalAnim =
    "#define MaxLights 4\n"
    "#define BONE_WEIGHTS_PER_VERTEX 4\n"
    "#ifndef NO_TEXTURE\n"
    "Texture2D texture0 : register(t0);\n"
    "SamplerState samplerLinear : register(s0);\n"
    "#endif\n"
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "    matrix worldMatrix;\n"
    "    matrix boneMatrices[CE_MAX_BONES_PER_SKELETON];\n"
    "};\n"
    "cbuffer DefaultConstantBuffer : register(b1)\n"
    "{\n"
    "#ifdef NO_TEXTURE\n"
    "    float4 ambient;\n"
    "#else\n"
    "    float1 uMod;\n"
    "    float1 vMod;\n"
    "    float1 uScale;\n"
    "    float1 vScale;\n"
    "#endif\n"
    "    float3 cameraPosition;\n"
    "    matrix lightParams[4];\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float4 weights0 : BLENDWEIGHT0;\n"
    "    uint4 indices0 : BLENDINDICES0;\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float2 uv : TEXCOORD;\n"
    "    float4 position : SV_Position;\n"
    "    float3 worldNormal : NORMAL;\n"
    "    float3 worldPosition : POSITION;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    float3 P = input.position;\n"
    "    float3 N = input.normal;\n"
    "    if (any(input.weights0))\n"
    "    {\n"
    "        P = 0.0f;\n"
    "        N = 0.0f;\n"
    "        for (int i = 0; i < BONE_WEIGHTS_PER_VERTEX; ++i)\n"
    "        {\n"
    "            P += mul(float4(input.position, 1.0f), boneMatrices[input.indices0[i]]).xyz * input.weights0[i];\n"
    "            N += mul(input.normal, float3x3(boneMatrices[input.indices0[i]][0].xyz, boneMatrices[input.indices0[i]][1].xyz, boneMatrices[input.indices0[i]][2].xyz)) * input.weights0[i];\n"
    "        }\n"
    "    }\n"
    "    P = float3(P.x, P.z, -P.y);\n"
    "    N = float3(N.x, N.z, -N.y);\n"
    "    output.uv = input.uv;\n"
    "    output.position = mul(float4(P, 1.0f), worldViewProjMatrix);\n"
    "    output.worldNormal = normalize(mul(N, float3x3(worldMatrix[0].xyz, worldMatrix[1].xyz, worldMatrix[2].xyz)));\n"
    "    output.worldPosition = mul(float4(P, 1.0f), worldMatrix).xyz;\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "    float4 colour;\n"
    "#ifdef NO_TEXTURE\n"
    "    colour = ambient;\n"
    "#else\n"
    "    colour = texture0.Sample(samplerLinear, float2(uScale * input.uv.x + uMod, vScale * input.uv.y + vMod));\n"
    "#endif\n"
    "    float3 L;\n"
    "    float3 diffuse = {0.0f, 0.0f, 0.0f};\n"
    "    float3 specular = {0.0f, 0.0f, 0.0f};\n"
    "    for (int i = 0; i < MaxLights; ++i)\n"
    "    {\n"
    "        L = normalize(float3(lightParams[i][0][0], lightParams[i][1][0], lightParams[i][2][0]) - input.worldPosition);\n"
    "        float distance = length(float3(lightParams[i][0][0], lightParams[i][1][0], lightParams[i][2][0]) - input.worldPosition);\n"
    "        float attenuation = 1.0f / (lightParams[i][0][3] + lightParams[i][1][3] * distance + lightParams[i][2][3] * (distance * distance));\n"
    "        if (distance > lightParams[i][3][3]) {attenuation = 0.0f;};\n"
    "        diffuse += mul(mul(float3(lightParams[i][0][1], lightParams[i][1][1], lightParams[i][2][1]), max(0.0f, dot(L, normalize(input.worldNormal)))), attenuation);\n"
    "        float specFactor = pow(max(0.0f, dot(reflect(-L, normalize(input.worldNormal)), normalize(cameraPosition - input.worldPosition))), lightParams[i][3][2]);\n"
    "        specular += mul(mul(float3(lightParams[i][0][2], lightParams[i][1][2], lightParams[i][2][2]), specFactor), attenuation);\n"
    "    }\n"
    "    colour.rgb = clamp(colour.rgb * (diffuse + specular), 0.0f, 1.0f);\n"
    "    output = colour;\n"
    "};\n";

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgramShadowCaster =
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "};\n"
    "cbuffer DefaultConstantBuffer : register(b1)\n"
    "{\n"
    "    float3 shadowColour;\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float4 position : SV_Position;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    output.position = mul(float4(input.position, 1.0f), worldViewProjMatrix);\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "    output = float4(shadowColour, 1.0);\n"
    "};\n";

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgramTransparentShadowCaster =
    "Texture2D texture0 : register(t0);\n"
    "SamplerState samplerLinear : register(s0);\n"
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "};\n"
    "cbuffer DefaultConstantBuffer : register(b1)\n"
    "{\n"
    "    float3 shadowColour;\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float2 uv : TEXCOORD;\n"
    "    float4 position : SV_Position;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    output.uv = input.uv;\n"
    "    output.position = mul(float4(input.position, 1.0f), worldViewProjMatrix);\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "    float4 albedo = texture0.Sample(samplerLinear, input.uv);\n"
    "#ifdef ALPHA_TEST\n"
    "    if (albedo.a < 0.001f) discard;\n"
    "#endif\n"
    "    output = float4(shadowColour, albedo.a);\n"
    "};\n";

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgramShadowReceiver =
    "Texture2D texture0 : register(t0);\n"
    "SamplerState samplerLinear : register(s0);\n"
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "    matrix textureMatrix;\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float4 uv : TEXCOORD;\n"
    "    float4 position : SV_Position;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    output.uv = mul(float4(input.position, 1.0f), textureMatrix);\n"
    "    output.position = mul(float4(input.position, 1.0f), worldViewProjMatrix);\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "    float4 colour = {1.0f, 1.0f, 1.0f, 1.0f};\n"
    "    if (input.uv.w > 0.0f)\n"
    "    {\n"
    "        colour = texture0.Sample(samplerLinear, input.uv.xy / input.uv.w);\n"
    "    }\n"
    "    output = colour;"
    "};\n";

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgramShadowCasterMorphAnim =
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "    float1 morphWeight;\n"
    "};\n"
    "cbuffer DefaultConstantBuffer : register(b1)\n"
    "{\n"
    "    float3 shadowColour;\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "    float2 uvTarget : TEXCOORD1;\n"
    "    float3 normalTarget : NORMAL1;\n"
    "    float3 positionMorphTarget : POSITION1;\n"
    "    float4 colourTarget : COLOR1;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float4 position : SV_Position;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    output.position = mul(float4((input.position + (input.positionMorphTarget - input.position) * morphWeight), 1.0f), worldViewProjMatrix);\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "    output = float4(shadowColour, 1.0);\n"
    "};\n";

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgramTransparentShadowCasterMorphAnim =
    "Texture2D texture0 : register(t0);\n"
    "SamplerState samplerLinear : register(s0);\n"
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "    float1 morphWeight;\n"
    "};\n"
    "cbuffer DefaultConstantBuffer : register(b1)\n"
    "{\n"
    "    float3 shadowColour;\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "    float2 uvMorphTarget : TEXCOORD1;\n"
    "    float3 normalTarget : NORMAL1;\n"
    "    float3 positionMorphTarget : POSITION1;\n"
    "    float4 colourTarget : COLOR1;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float2 uv : TEXCOORD;\n"
    "    float4 position : SV_Position;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    output.uv = input.uv + (input.uvMorphTarget - input.uv) * morphWeight;\n"
    "    output.position = mul(float4((input.position + (input.positionMorphTarget - input.position) * morphWeight), 1.0f), worldViewProjMatrix);\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "    output = float4(shadowColour, texture0.Sample(samplerLinear, input.uv).a);\n"
    "};\n";

//------------------------------------------------------------------------------
/**
*/
const char* const DefaultGpuProgramShadowCasterSkeletalAnim =
    "#define BONE_WEIGHTS_PER_VERTEX 4\n"
    "cbuffer AutoConstantBuffer : register(b0)\n"
    "{\n"
    "    matrix worldViewProjMatrix;\n"
    "    matrix boneMatrices[CE_MAX_BONES_PER_SKELETON];\n"
    "};\n"
    "cbuffer DefaultConstantBuffer : register(b1)\n"
    "{\n"
    "    float3 shadowColour;\n"
    "};\n"
    "struct VertexIn\n"
    "{\n"
    "    float4 weights0 : BLENDWEIGHT0;\n"
    "    uint4 indices0 : BLENDINDICES0;\n"
    "    float2 uv : TEXCOORD0;\n"
    "    float3 normal : NORMAL0;\n"
    "    float3 position : POSITION0;\n"
    "    float4 colour : COLOR0;\n"
    "};\n"
    "struct VertexOut\n"
    "{\n"
    "    float4 position : SV_Position;\n"
    "};\n"
    "void DefaultVertexShader(VertexIn input, out VertexOut output)\n"
    "{\n"
    "    float3 P = input.position;\n"
    "    if (any(input.weights0))\n"
    "    {\n"
    "        P = 0.0f;\n"
    "        for (int i = 0; i < BONE_WEIGHTS_PER_VERTEX; ++i)\n"
    "        {\n"
    "            P += mul(float4(input.position, 1.0f), boneMatrices[input.indices0[i]]).xyz * input.weights0[i];\n"
    "        }\n"
    "    }\n"
    "    P = float3(P.x, P.z, -P.y);\n"
    "    output.position = mul(float4(P, 1.0f), worldViewProjMatrix);\n"
    "}\n"
    "void DefaultFragmentShader(VertexOut input, out float4 output : SV_Target)\n"
    "{\n"
    "   output = float4(shadowColour, 1.0);\n"
    "};\n";
//------------------------------------------------------------------------------
#endif